## 03. 자바와 객체 지향

### 상속과 인터페이스

상속

- 객체 지향의 상속은 클래스의 특성을 재사용, 확장하는 것이다.
- 객체 지향의 상속은 **is a kind of** 관계를 만족해야한다. → 하위 클래스는 상위 클래스의 한 분류이다.
- 예: 고래는 동물의 한 분류이다.

인터페이스

- 인터페이스는 **be able to**, 즉 "~을 할 수 있는" 형태로 만드는 것이 좋다.
- 구현 클래스 is able to 인터페이스 → 구현 클래스는 인터페이스 할 수 있다.
- 자바 API에서 인터페이스 be able to 의 예
  - Serializable :  직렬화 할 수 있는
  - Cloneable : 복제할 수 있는
  - Comparable : 비교할 수 있는
  - Runnalbe : 실행할 수 있는

상속과 T메모리

- **힙영역에 하위 클래스의 인스턴스가 생성될 때 상위 클래스의 인스턴스도 함께 생성된다.(최상위 클래스인 Object도)**

### 다형성 : 사용편의성

객체지향에서 다형성은 오버라이딩(overriding)과 오버로딩(overloading)이라고 할 수 있다.

- 오버라이딩 : 재정의, 상위 클래스의 메서드와 같은  메서드 이름, 같은 인자 리스트
- 오버로딩 : 중복 정의, 같은 메서드 이름, 다른 인자 리스트

**하위 클래스에서 어떤 메서드를 오버라이딩하고, 상위 클래스의 타입의 객체 참조 변수를 사용할 때, 상위 클래스의 메서드가 아닌 하위 클래스에서 오버라이딩한 메서드가 호출된다.**

오버로딩은 하나의 메서드명으로 인자 목록만 다르게하면되서 사용하기 편리하다.

제네릭을 이용하면 하나의 메서드만 구현해도 다수의 메서드를 구현한 효과를 낼 수 있다.

### 캡슐화 : 정보은닉

접근 제어자 UML 표기

- - : private

- ~ : default

- # : protected

- - : public

- 속성이나 메서드에 _(밑줄)을 사용한 경우는 정적 멤버

**캡! 상추다 : 캡슐화 상속 추상화 다형성**

## 04 자바가 확장한 객체 지향

클래스 정보는 해당 클래스가 코드에서 맨 처음 사용될 때 T 메모리의 스태틱 영역에 로딩되며, 이때 단 한번 해당 클래스의 static 블록이 실행된다.

클래스가 맨 처음 사용될 때는 다음 3가지 경우 중 하나

1. 클래스의 정적 속성을 사용할때
2. 클래스의 정적 메서드를 사용할 때
3. 클래스의 인스턴스를 최초로 만들 때

인스턴스 블럭 {} 은 인스턴스가 생성될 때 마다 실행되며 객체 생성자가 실행되기 전에 먼저 실행된다.

final

- 클래스에 붙은 final : 상속을 허용하지 않는다.
- 변수에 붙은 final : 상수
- 메서드에 붙은 final : 오버라이딩을 허용하지 않는다.

객체를 생성할 때마다 똑같은 객체 멤버 메서드를 힙 영역에 만드는 것은 심각한 메모리 낭비이다. 그래서 JVM은 객체 멤버 메서드를 static 영역에 단 하나만 보유한다. 그리고 어떤 객체에서 호출한 것인지 구분하기 위해  눈에 보이진 않지만 메서드를 호출할 때 this 객체 참조 변수를 넘긴다.

## 05. 객체 지향 설계 5원칙 - SOLID

SOLID는 로버트 C. 마틴이 2000년대 초반 객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙으로 제시한 것을 마이클 페더스가 두분자어로 소개한 것이다.

응집도는 높이고, 결합도는 낮추라는 고전 원칙을 객체 지향의 관점에서 재정립 한것이라고 할 수 있다.

좋은 소프트웨어 설계를 위해서는 결합도를 낮추고, 응집도를 높이는 것이 좋다.

- 결합도 : 모듈(클래스)간의 상호 의존 정도, 결합도가 낮으면 모듈간의 상호 의존성이 줄어들어 객체의 재사용, 수정, 유지보수가 용이하다.
- 응집도 : 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성, 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져 재사용, 기능의 수정, 유지보수가 용이하다.

### SRP(Single Responsibility Principle) : 단일 책임 원칙

속성, 메서드, 패키지, 모듈, 컴포넌트, 프레임워크 등을 역할과 책임에 따라 분리해서 각각 하나의 역할과 책임만 가지도록 하자는 원칙

#### 속성이 단일 책임을 지키지 못한 경우

사례1

예를 들어 남자는 군대를 가고, 여자는 군대를 절대 가지 않는다. 그런데 사람 클래스에 군번 속성이 있다면?

여자 참조 변수가 가진 군번 속성에 값을 할당하거나 읽어오는 코드를 제거할 방법이 없다.

해결 방법

사람 클래스를 남자 클래스와 여자 클래스로 분할하고 남자클래스만 군번 속성을 가지도록 한다.

남자 클래스와 여자 클래스의 공통점이 없다면 사람 클래스 삭제, 공통점이 많다면 사람 클래스를 상위  클래스로하여 여자, 남자 클래스는 사람 클래스를 상속한다.

사례2 - 하나의 속성이 여러 의미를 갖는 경우

DB 테이블의 한 필드가 토지인 경우 면적을, 건물인 경우 층수를 나타내는 경우

#### 메서드가 단일 책임을 지키지 못한 경우

```java
class Dog {
	final static Boolean male = true;
	final static Boolean female = false;
	Boolean sex;

	void fee() {
		if(this.sex == male) {
			//한쪽 다리를 들고 소변을 본다.
		} else {
			//뒷다리 두개로 앉은 자세로 소변을 본다.
		}
	}
}
```

위 코드를 보면 강아지의 성별에 따라 fee 메서드에서 분기 처리가 진행되는 것을 볼 수 있다. 수컷 강아지와 암컷 강아지의 경우를 모두 구현하려고 하기 때문에 단일 책임 원칙을 위배하는 것이다.

**메서드가 단일 책임을 지키지 않을 경우 나타나는 대표적인 냄새가 분기 처리를 위한 if 문이다.**

위 코드를 단일 책임 원칙을 적용해 리팩터링하면 다음과 같이 작성할 수 있다.

```java
abstract class Dog {
	abstract void fee();
}

class MaleDog extends Dog {
	void fee() {
		//한쪽 다리를 들고 소변을 본다.
	}
}

class FemaleDog extends Dog {
	void fee() {
		//뒷다리 두개로 앉은 자세로 소변을 본다.
	}
}
```

### OCP - 개방 폐쇄 원칙

**"자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야한다."**

```java
class 아반떼 {
	창문수동개방() {}
	기어수동조작() {}
}

class 쏘나타 {
	창문자동개방() {}
	기어자동조작() {}
}
```

예를 들어 아반떼를 운전하던 운전자는 쏘나타로 차를 바꾸면 기어 조작, 창문 개방 행동에 변화가 온다. 즉, 다른 메서드를 사용하게 된다. → 개방 폐쇄 원칙 위반

```java
abstract class 자동차 {
	abstract 창문개방();
	abstract 기어조작();
}

class 아반떼 extends 자동차 {
	창문개방() {}
	기어조작() {}
}

class 쏘나타 extends 자동차 {
	창문개방() {}
	기어조작() {}
}
```

위와 같이 상위 클래스 또는 인터페이스를 운전자와 자동차 사이에 둠으로써 여러 개의 자동차가 생겨도 운전자는 영향을 받지 않게된다.

**즉, 다양한 자동차가 생긴다는 것은 자동차 입장에서 자신의 확장에 열려있는 것이고, 운전자 입장에서는 주변의 변화에 닫혀 있는 것이다.**

개방 폐쇄 원칙을 지키지 않으면 객체지향의 가장 큰 장점인 유연성, 재사용성, 유지보수성 등을 얻을 수 없다. 반드시 지키자!

### LSP - 리스코프 치환 원칙

**하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야한다.**

- 하위 클래스 is kind of 상위 클래스 → 하위 클래스는 상위 클래스의 한 종류다
- 구현 클래스 is able to 인터페이스 → 구현 클래스는 인터페이스 할 수 있어야한다.

위 두문장을 만족하면 리스코프 치환 원칙을 잘 지키고 있다고 볼 수 있다.

### ISP - 인터페이스 분리 법칙

클라이언트는 자신이 사용하지 않는 메서드에 의존관계를 맺으면 안된다.

단일 책임 원칙에 따라 클래스를 역할에 따라 여러 클래스로 분할하는 것이 아닌, 특정 경우에서는 특정 역할만 할 수 있도록 인터페이스로 제한하는 것이다.

결론적으로 단일 책임 원칙과 인터페이스 분리 원칙은 같은 문제에 대한 서로 다른 두가지 해결책 인 것이다.

둘 중 하나를 선택해서 설계할 수 있지만, 대부분 단일 책임 원칙을 선택하는 것이 더 좋은 해결책인 경우가 많다.

### DIP - 의존 역전 원칙

자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향 받지 않게 하는 것이 의존 역전 원칙이다. → 개방 폐쇄 원칙과 비슷

상위 클래스일수록, 인터페이스일수록, 추상 클래스일수록 변하지 않을 가능성이 높기 때문에 하위 클래스나 구체 클래스가 아닌 상위 클래스, 인터페이스, 추상 클래를 통해 의존하라는 것이 의존 역전 원칙이다.

### 정리

**SoC**

SoC는 관심사의 분리(Separation of Concerns)의 약자로 관심이 같은 것 끼리 하나의 객체 또는 친한 객체로 모으고, 관심이 다른 것은 가능한 따로 떨어져 서로 영향을 주지않도록 분리하라는 것이다.

하나의 속성, 하나의 클래스, 하나의 모듈, 하나의 패키지에는 하나의 관심사만 들어있어야 한다.

SoC를 적용하면 자연스럽게 단일 책임 원칙(SRP), 인터페이스 분리 원칙(ISP), 개방 폐쇄 원칙(OCP)가 적용된다.

SOLID 원칙을 적용하면 소스 파일의 개수가 더 많아지는 경향이 있지만, 많아진 파일이 논리를 더욱 잘 분할하고, 잘 표현하기에 이해하기 쉽고, 개발하기 쉬우며, 유지보수하기 쉬운 소스가 만들어진다.