# 객체지향 프로그래밍 입문 인프런 강의 정리

## 객체

절차 지향 vs 객체지향

절차지향

- 여러 프로시저가 데이터를 공유해서 사용하는 방식
- 시간이 흘러갈수록 데이터를 공유하는 방식은 구조가 점점 복잡해지고 수정을 어렵게 만드는 요인이 된다.

객체지향

- 데이터와 프로지서를 객체라는 단위로 묶고, 데이터는 해당 객체의 프로시저만 접근하 수 있도록한다.
- 처음에는 어려울 수 있지만, 시간이 흘러갈수록 코드를 수정하기 수월해진다.

객체

- **객체의 핵심은 기능을 제공하는 것**
    - **객체는 필드가 아닌 제공하는 기능으로 정의**
- 예: 회원 객체 → 암호 변경하기 기능, 차단 여부 확인하기 기능
- 메서드를 이용해서 기능 명세, 메서드를 호출해서 기능 사용
- 특별한 기능없이  게터, 세터 정도 제공하는 클래스는 객체보다는 데이터 클래스에 더 가깝다.
- 메시지
    - 객체와 객체가 상호작용(메서드를 호출, 리턴)하는 것을 메시지를 주고받는다고 표현
    - 메서드를 호출하는 메시지, 리턴하는 메시지, 익셉션 메시지

## 캡슐화

- 데이터와 관련 기능 묶기
- 객체가 기능을 어떻게 구현했는지 외부에 감추는 것
- 기능을 제공하고 구현 상세를 감춤
- 정보 은닉(데이터를 외부에 감추는 것) 의미 포함
- 외부에 영향 없이 객체 내부 구현 변경 가능

캡슐화를 하지 않으면 요구사항 변화로 데이터 구조/사용에 변화가 발생했을 때 데이터를 사용하는 많은 코드에 수정이 발생한다.

캡슐화를 하면 요구사항 변화로 데이터 구조/사용에 변화가 발생했을 때 기능을 사용하는 코드에는 영향이 없고, 캡슐화된 내부 구현만 변경하면된다.→ 캡슐화는 연쇄적인 변경 전파를 최소화

캡슐화 시도 → 메서드를 통해 기능을 제공하고, 메서드 이름을 통해 기능을 유추할 수 있다 → 기능에 대한 (의도)이해를 높임

### 캡슐화 규칙

1. Tell, Don't Ask : 데이터를 달라 하지 말고 해달라고 하기
    - 객체에 있는 데이터를 직접 가져와서 판단하여 사용하지 말고,  데이터를 가지고 있는 객체에서 메서드를 통해 데이터를 판단하여 기능을 제공하자
    - 예를 들어 회원의 등급이 VIP인지 알아야 된다면, 회원 객체의 등급 필드에 직접 접근하는 것이 아닌 isVipMember와 같은 메서드를 통해 VIP회원이 맞는지 확인한다

2. Demeter's Law

   - 메서드에서 생성한 객체의 메서드만 호출

   - 파라미터로 받은 객체의 메서드만 호출

   - 필드로 참조하는 객체의 메서드만 호출

### 정리

- 캡슐화는 기능의 구현을 외부에 감춤
- 캡슐화를 통해 기능을 사용하는 코드에 영향을 주지 않고(또는 최소화) 내부 구현을 변경할 수 있는 유연함
- 캡슐화를 잘할수록 수정에 들어가는 비용을 낮출 수 있는 가능성이 높아진다.

## 다형성과 추상화

### 다형성

- 여러 모습을 갖는 것
- 객체지향에서 다형성은 상속을 이용해서 구현 → 하위 타입은 상위 타입으로 사용 가능

### 타입 추상화

- 상속을 사용하는 것으로 여러 구현 클래스의 공통 상위 타입(인터페이스)을 뽑아내는 것
- 추상 타입을 사용함으로써 클라이언트를 변경하지 않고 상황에 따라 구현 클래스를 바꿔  끼우면 되기 때문에 변경에 유연해진다. → OCP
- 구현 클래스를 콘크리트(concrete)클래스 라고도 한다.
- 불필요한 추상화는 오히려 복잡도를 증가시킨다. 무조건 추상화를 하기보다는 실제 변경, 확장이 발생할 때 추상화를 시도하면 프로그램의 복잡도는 증가시키지 않으면서 유연함을 가질 수 있게 된다.

## 상속보단 조립

어떤 기능을 재사용, 확장을 할 때 상속을 사용하면 클래스 수의 증가와 더불어 상위 클래스의 변경이 모든 하위 클래스에 영향을 주고, 상속을 오용하는 상황이 발생할 수 있다.

이러한 상속의 문제점을 해결하는 방법은 조립을 사용하는 것이다. 조립은 필드를 통해 다른 객체를 참조하거나 또는 필요한 시점에 객체를 생성해서 사용하는 방법으로, 보통 상속보다는 조립을 사용하는 것이 더 좋은 선택인 경우가 많다.

그렇기 때문에 클래스의 기능을 재사용할 때, 상속보다는 먼저 조립으로 풀 수 있는 문제인지 생각해 보고, 정말 하위 타입인 경우에만 상속을 사용하자.

```java
//상속의 예
class A { ... }

class B extends A { ... }

class C extends A { ... }

class D extends A { ... }

//조립의 예
class A {
	B b;
	C c;
	D d;
}
```

