# 객체지향 프로그래밍 입문 인프런 강의 정리

## 객체

절차 지향 vs 객체지향

절차지향

- 여러 프로시저가 데이터를 공유해서 사용하는 방식
- 시간이 흘러갈수록 데이터를 공유하는 방식은 구조가 점점 복잡해지고 수정을 어렵게 만드는 요인이 된다.

객체지향

- 데이터와 프로지서를 객체라는 단위로 묶고, 데이터는 해당 객체의 프로시저만 접근하 수 있도록한다.
- 처음에는 어려울 수 있지만, 시간이 흘러갈수록 코드를 수정하기 수월해진다.

객체

- **객체의 핵심은 기능을 제공하는 것**
    - **객체는 필드가 아닌 제공하는 기능으로 정의**
- 예: 회원 객체 → 암호 변경하기 기능, 차단 여부 확인하기 기능
- 메서드를 이용해서 기능 명세, 메서드를 호출해서 기능 사용
- 특별한 기능없이  게터, 세터 정도 제공하는 클래스는 객체보다는 데이터 클래스에 더 가깝다.
- 메시지
    - 객체와 객체가 상호작용(메서드를 호출, 리턴)하는 것을 메시지를 주고받는다고 표현
    - 메서드를 호출하는 메시지, 리턴하는 메시지, 익셉션 메시지

## 캡슐화

- 데이터와 관련 기능 묶기
- 객체가 기능을 어떻게 구현했는지 외부에 감추는 것
- 기능을 제공하고 구현 상세를 감춤
- 정보 은닉(데이터를 외부에 감추는 것) 의미 포함
- 외부에 영향 없이 객체 내부 구현 변경 가능

캡슐화를 하지 않으면 요구사항 변화로 데이터 구조/사용에 변화가 발생했을 때 데이터를 사용하는 많은 코드에 수정이 발생한다.

캡슐화를 하면 요구사항 변화로 데이터 구조/사용에 변화가 발생했을 때 기능을 사용하는 코드에는 영향이 없고, 캡슐화된 내부 구현만 변경하면된다.→ 캡슐화는 연쇄적인 변경 전파를 최소화

캡슐화 시도 → 메서드를 통해 기능을 제공하고, 메서드 이름을 통해 기능을 유추할 수 있다 → 기능에 대한 (의도)이해를 높임

### 캡슐화 규칙

1. Tell, Don't Ask : 데이터를 달라 하지 말고 해달라고 하기
    - 객체에 있는 데이터를 직접 가져와서 판단하여 사용하지 말고,  데이터를 가지고 있는 객체에서 메서드를 통해 데이터를 판단하여 기능을 제공하자
    - 예를 들어 회원의 등급이 VIP인지 알아야 된다면, 회원 객체의 등급 필드에 직접 접근하는 것이 아닌 isVipMember와 같은 메서드를 통해 VIP회원이 맞는지 확인한다

2. Demeter's Law

   - 메서드에서 생성한 객체의 메서드만 호출

   - 파라미터로 받은 객체의 메서드만 호출

   - 필드로 참조하는 객체의 메서드만 호출

### 정리

- 캡슐화는 기능의 구현을 외부에 감춤
- 캡슐화를 통해 기능을 사용하는 코드에 영향을 주지 않고(또는 최소화) 내부 구현을 변경할 수 있는 유연함
- 캡슐화를 잘할수록 수정에 들어가는 비용을 낮출 수 있는 가능성이 높아진다.

## 다형성과 추상화

### 다형성

- 여러 모습을 갖는 것
- 객체지향에서 다형성은 상속을 이용해서 구현 → 하위 타입은 상위 타입으로 사용 가능

### 타입 추상화

- 상속을 사용하는 것으로 여러 구현 클래스의 공통 상위 타입(인터페이스)을 뽑아내는 것
- 추상 타입을 사용함으로써 클라이언트를 변경하지 않고 상황에 따라 구현 클래스를 바꿔  끼우면 되기 때문에 변경에 유연해진다. → OCP
- 구현 클래스를 콘크리트(concrete)클래스 라고도 한다.
- 불필요한 추상화는 오히려 복잡도를 증가시킨다. 무조건 추상화를 하기보다는 실제 변경, 확장이 발생할 때 추상화를 시도하면 프로그램의 복잡도는 증가시키지 않으면서 유연함을 가질 수 있게 된다.

## 상속보단 조립

어떤 기능을 재사용, 확장을 할 때 상속을 사용하면 클래스 수의 증가와 더불어 상위 클래스의 변경이 모든 하위 클래스에 영향을 주고, 상속을 오용하는 상황이 발생할 수 있다.

이러한 상속의 문제점을 해결하는 방법은 조립을 사용하는 것이다. 조립은 필드를 통해 다른 객체를 참조하거나 또는 필요한 시점에 객체를 생성해서 사용하는 방법으로, 보통 상속보다는 조립을 사용하는 것이 더 좋은 선택인 경우가 많다.

그렇기 때문에 클래스의 기능을 재사용할 때, 상속보다는 먼저 조립으로 풀 수 있는 문제인지 생각해 보고, 정말 하위 타입인 경우에만 상속을 사용하자.

```java
//상속의 예
class A { ... }

class B extends A { ... }

class C extends A { ... }

class D extends A { ... }

//조립의 예
class A {
	B b;
	C c;
	D d;
}
```

## 기능과 책임 분리

여러 기능이 하나의 클래스나 메서드에 섞여있으면, 많은 필드나 변수를 공유해서 사용, 변경할 가능성이 높아지고 수정하기 어려운 구조로 이어지게 된다.

그렇기 때문에 클래스 또는 메서드의 크기가 커지면 책임, 기능에 따라 코드를 분리하는 것이 좋다. 책임을 분리하는 방법 중 몇 가지는 다음과 같다.

- 계층 분리(예 : Controller-Service-Repository), 디자인 패턴 적용, AOP 등 패턴을 적용
- 계산 로직 분리
- 네트워크, 파일 등 연동 로직 분리
- 조건 분기는 추상화와 하위 클래스의 형태로 분리

## 의존과 DI

### 의존

의존은 기능 구현을 위해 다른 객체를 생성하거나, 메서드를 호출, 데이터를 사용하는 것을 말한다.

의존하는 대상은 적을수록 좋다. 의존 대상이 적을수록 의존 대상이 변경되더라도 클라이언트 쪽에 영향을 미칠 가능성이 낮아지기 때문이다.

의존 대상이 많은 경우

- 한 클래스에서 많은 기능을 제공하고, 의존 대상이 많은 경우 클래스를 각 기능 별로 분리해 보는 것을 생각해 보자.
- 몇 가지 의존 대상을 단일 기능으로 합쳐서 사용할 수 있는지 생각해 보자.

### DI

의존하는 객체를 클라이언트 쪽에서 직접 생성해서 사용하면 생성 클래스를 바꿔야 될 때 클라이언트의 코도도 같이 변경해야 되는 상황이 발생할 가능성이 놓  된다.

의존 주입을 통해 클라이언트 쪽에서 직접 의존 객체를 생성하지 않고 생성자나 메서드를 통해 외부로부터 주입받아서 사용할 수 있다.

스프링의 `@Configuration` 클래스와 같은 조립기에서 의존 객체를 생성하고, 주입을 처리한다.

장점

- 추상 타입을 사용해서 의존 객체를 주입 받으면 구현체가 변경되어도 조립기에서 구현체를 갈아끼우기만 하면 된다.
- DI를 사용하면 테스트 코드 작성시 실제 객체가 아닌 테스트용 객체를 만들어 주입해서 테스트를 실행할 수 있다.

참고: 의존 객체를 직접 생성하지 않는 방법에는 DI외에도 팩토리, 빌더, 서비스 로케이터가 있다.

**의존 객체는 DI를 사용해 주입 받아 사용하는 습관을 가지자**

